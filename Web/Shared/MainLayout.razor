@using System.Collections
@using _progressiveBotSystem.Helpers
@using _progressiveBotSystem.Models
@using _progressiveBotSystem.Models.Enums
@using SPTarkov.Server.Core.Models.Common
@using SPTarkov.Server.Core.Models.Eft.Common.Tables
@using Color = MudBlazor.Color
@inherits LayoutComponentBase

@implements IAsyncDisposable
@inject NavigationManager NavManager
@inject DataLoader Dataloader
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime Js

<HeadContent>
    <link href="@Assets["_content/MudBlazor/MudBlazor.min.css"]" rel="stylesheet" />
    <meta name="robots" content="noindex, nofollow">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;family=Roboto:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet">
    <script src="@Assets["_content/MudBlazor/MudBlazor.min.js"]"></script>
</HeadContent>

<MudThemeProvider Theme="@APBSThemeAdjustments" IsDarkMode/>
<MudPopoverProvider/>
<MudSnackbarProvider />
<MudDialogProvider />

@if (!_appRequireAuthCode || _isAuthenticated)
{
    <div class="no-highlight">
        <MudLayout>
            <MudAppBar Dense Elevation="1">
                <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.MenuOpen" Color="Color.Inherit" OnClick="@((e) => DrawerToggle())">Menu</MudButton>
                <MudSpacer/>
                <MudOverlay Visible="_isInRaid" DarkBackground="true" Absolute="true">
                    <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="RefreshPage">
                        You or someone you know is in raid. Changes cannot be made. Click to check status.
                    </MudButton>
                </MudOverlay>
                <MudSpacer/>
                <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Refresh" Color="Color.Inherit" OnClick="@((e) => RefreshData())" Disabled="_isReloading">Reload Config</MudButton>
                <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Save" Color="Color.Inherit" OnClick="@((e) => SaveData())" Disabled="_isSaving">Save Config</MudButton>
            </MudAppBar>
            <MudDrawer @bind-Open="_drawerOpen" Elevation="2" ClipMode="DrawerClipMode.Always" Variant="@DrawerVariant.Temporary" Breakpoint="Breakpoint.None">
                <MudDrawerHeader>
                    <MudText Typo="Typo.h5" Class="mt-1">SETTINGS</MudText>
                </MudDrawerHeader>
                <NavMenu/>
            </MudDrawer>
            <MudMainContent Class="pt-3">
                <MudOverlay Visible="_isInRaid" DarkBackground="true" Absolute="true"/>
                <CascadingValue Value="this">
                    @if (_appDisableAnimations)
                    {
                        <div class="no-animation-content">
                            @Body
                        </div>
                    }
                    else
                    {
                        <div class="content">
                            @Body
                        </div>
                    }
                </CascadingValue>
            </MudMainContent>
            <MudAppBar Dense Elevation="1" Bottom>
                <MudCheckBox @bind-Value="_appUndoButtonToggle" Label="Show Undo Button"/>
                <MudCheckBox @bind-Value="_appDefaultButtonToggle" Label="Show Default Button"/>
                <MudCheckBox @bind-Value="_appDisableAnimations" Label="Disable Animations"/>
                <MudCheckBox @bind-Value="_appAllowUpdateChecks" Label="Enable Update Checks"/>
                <MudCheckBox @bind-Value="_appRequireAuthCode" Label="Enable Authorization Code Access" Disabled="@( !_appRequireAuthCode )"/>
                <MudSpacer/>
                @if (pendingChanges.Count > 0)
                {
                    <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="ShowPendingChanges">@pendingChanges.Count.ToString() Unsaved changes</MudButton>
                }
                @if (pendingChanges.Count == 0)
                {
                    <MudButton Variant="Variant.Outlined" Color="Color.Inherit">@pendingChanges.Count.ToString() Unsaved Changes</MudButton>
                }
            </MudAppBar>
        </MudLayout>
    </div>
}
else
{
    <MudPaper Class="pa-4 mx-auto mt-10" Style="width: 350px">
        <MudText Typo="Typo.h5">Enter Access Code</MudText>

        <MudTextField @bind-Value="_authCode" Label="Access Code" Margin="Margin.Dense" />

        @if (_authFailed)
        {
            <MudText Color="Color.Error">Invalid code</MudText>
        }

        <MudButton Variant="Variant.Filled" OnClick="CheckAuth" Class="mt-3" Color="Color.Primary">
            Login
        </MudButton>
    </MudPaper>
}

<style>
    .custom-blur-background {
        backdrop-filter: blur(7px);
    }
    #blazor-error-ui {
        background: lightyellow;
        bottom: 0;
        box-shadow: 0 -1px 2px rgba(0, 0, 0, 0.2);
        display: none;
        left: 0;
        padding: 0.6rem 1.25rem 0.7rem 1.25rem;
        position: fixed;
        width: 100%;
        z-index: 1000;
        color: red;
        margin-left: 3rem;
    }

    #blazor-error-ui .dismiss {
        cursor: pointer;
        position: absolute;
        right: 0.75rem;
        top: 0.5rem;
    }

    .no-highlight {
        -webkit-user-drag: none;
        -webkit-user-select: none;
        user-select: none;
    }

    :scope .content {
        overflow: auto;
        position: relative;
        animation-name: transition;
        animation-duration: 1.5s;
        animation-delay: 0s;
        animation-fill-mode: forwards;
    }

    .content::before {
        content: "";
        position: fixed;
        background-position: 0px 0px;
        top: 0;
        left: 0;
        right: 0;
        z-index: -1;
        display: block;
        width: 100%;
        height: 100%;
        background-image: url('/acidphantasm-progressivebotsystem/images/background.jpg');
        background-size: cover;
        -webkit-filter: blur(4px);
        -moz-filter: blur(4px);
        filter: blur(4px);
        animation-name: transitionBG;
        animation-duration: 3.5s;
        animation-delay: 1s;
        animation-fill-mode: forwards;
    }

    :scope .no-animation-content {
        overflow: auto;
        position: relative;
        user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
    }

    .no-animation-content::before {
        content: "";
        position: fixed;
        background-position: 0px 0px;
        top: 0;
        left: 0;
        right: 0;
        z-index: -1;
        display: block;
        background-image: url('/acidphantasm-progressivebotsystem/images/background.jpg');
        background-size: cover;
        width: 100%;
        height: 100%;
        -webkit-filter: blur(4px);
        -moz-filter: blur(4px);
        filter: blur(4px);
    }
</style>


@code {
    private static MainLayout? _app;
    public static event Action? OnPresetChanged;
    public static event Action? OnPresetSaved;
    private IDisposable _locationChangingRegistration;
    
    bool _drawerOpen = false;
    public bool _isInRaid = false;
    
    static bool _unsavedChanges = false;
    public static List<string> pendingChanges = new();
    private static bool _isSaving = false;
    private static bool _isReloading = false;
    public static bool AlreadyCheckedForUpdate = false;
    public static bool UpdateAvailable = false;
    
    private bool _isAuthenticated = false;
    private string _authCode;
    private bool _authFailed;
    
    
    // Equipment Tracking Changes
    public static Dictionary<string, double> EquipmentWeightChanges = new();
    public static HashSet<string> EquipmentRemovedItems = new();
    public static HashSet<string> EquipmentAddedItems = new();
    
    // Ammo Tracking Changes
    public static Dictionary<string, double> AmmoWeightChanges = new();
    public static HashSet<string> AmmoRemovedItems = new();
    public static HashSet<string> AmmoAddedItems = new();
    
    // Chances Tracking
    public static Dictionary<string, double> ChancesWeightChanges = new();
    public static Dictionary<string, double> GenerationWeightChanges = new();
    public static Dictionary<string, double> GenerationWhitelistWeightChanges = new();
    public static HashSet<string> GenerationWhitelistRemovedItems = new();
    public static HashSet<string> GenerationWhitelistAddedItems = new();
    
    // Appearance Tracking Changes
    public static Dictionary<string, double> AppearanceWeightChanges = new();
    public static HashSet<string> AppearanceRemovedItems = new();
    public static HashSet<string> AppearanceAddedItems = new();
    
    public static bool _appRequireAuthCode
    {
        get => ModConfig.Config.ConfigAppSettings.RequireAuthCode; 
        set {
            ModConfig.Config.ConfigAppSettings.RequireAuthCode = value;
            Utils.UpdateView(value, ModConfig.OriginalConfig.ConfigAppSettings.RequireAuthCode);
        }
    }
    
    public static bool _appUndoButtonToggle
    {
        get => ModConfig.Config.ConfigAppSettings.ShowUndo; 
        set { 
            ModConfig.Config.ConfigAppSettings.ShowUndo = value;
            Utils.UpdateView(value, ModConfig.OriginalConfig.ConfigAppSettings.ShowUndo);
        }
    }
    public static bool _appDefaultButtonToggle
    {
        get => ModConfig.Config.ConfigAppSettings.ShowDefault;
        set
        {
            ModConfig.Config.ConfigAppSettings.ShowDefault = value;
            Utils.UpdateView(value, ModConfig.OriginalConfig.ConfigAppSettings.ShowDefault);
        }
    }
    public static bool _appDisableAnimations
    {
        get => ModConfig.Config.ConfigAppSettings.DisableAnimations;
        set
        {
            ModConfig.Config.ConfigAppSettings.DisableAnimations = value;
            Utils.UpdateView(value, ModConfig.OriginalConfig.ConfigAppSettings.DisableAnimations);
        }
    }
    public static bool _appAllowUpdateChecks
    {
        get => ModConfig.Config.ConfigAppSettings.AllowUpdateChecks;
        set
        {
            ModConfig.Config.ConfigAppSettings.AllowUpdateChecks = value;
            Utils.UpdateView(value, ModConfig.OriginalConfig.ConfigAppSettings.AllowUpdateChecks);
        }
    }
    
    private async Task CheckAuth()
    {
        if (_authCode == ModConfig.Config.ConfigAppSettings.AuthCode)
        {
            _isAuthenticated = true;

            await Js.InvokeVoidAsync("sessionStorage.setItem", "modAuth", "true");
            StateHasChanged();
        }
        else
        {
            _authFailed = true;
        }
    }
    
    protected override void OnInitialized()
    {
        _locationChangingRegistration = NavManager.RegisterLocationChangingHandler(OnLocationChanging);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var stored = await Js.InvokeAsync<string>("sessionStorage.getItem", "modAuth");
            _isAuthenticated = stored == "true";

            StateHasChanged();
        }
    }
    
    private ValueTask OnLocationChanging(LocationChangingContext context)
    {
        if (HasPendingPresetChanges() || HasPendingPresetNameOrFolderChange())
        {
            context.PreventNavigation();
            ShowPendingChangesDialog();
        }

        return ValueTask.CompletedTask;
    }

    private bool HasPendingPresetNameOrFolderChange()
    {
        return pendingChanges.Contains("_presetName")
               || pendingChanges.Contains("_presetEnable");
    }

    private bool HasPendingPresetChanges()
    {
        return EquipmentWeightChanges.Count > 0
               || AmmoWeightChanges.Count > 0
               || ChancesWeightChanges.Count > 0
               || GenerationWeightChanges.Count > 0
               || GenerationWhitelistWeightChanges.Count > 0
               || EquipmentAddedItems.Count > 0
               || EquipmentRemovedItems.Count > 0
               || AmmoAddedItems.Count > 0
               || AmmoRemovedItems.Count > 0
               || GenerationWhitelistAddedItems.Count > 0
               || GenerationWhitelistRemovedItems.Count > 0
               || AppearanceWeightChanges.Count > 0
               || AppearanceAddedItems.Count > 0
               || AppearanceRemovedItems.Count > 0;
    }

    private void ClearPendingChanges()
    {
        pendingChanges.Clear();
        EquipmentWeightChanges.Clear();
        EquipmentRemovedItems.Clear();
        EquipmentAddedItems.Clear();
        AmmoWeightChanges.Clear();
        AmmoRemovedItems.Clear();
        AmmoAddedItems.Clear();
        ChancesWeightChanges.Clear();
        GenerationWeightChanges.Clear();
        GenerationWhitelistWeightChanges.Clear();
        GenerationWhitelistRemovedItems.Clear();
        GenerationWhitelistAddedItems.Clear();
        AppearanceAddedItems.Clear();
        AppearanceRemovedItems.Clear();
        AppearanceWeightChanges.Clear();
        Utils.callerList.Clear();
    }

    private async void ShowPendingChangesDialog()
    {
        // Build a list of all changed items
        var changeList = new List<string>();

        changeList.AddRange(EquipmentAddedItems.Select(x => $"Equipment Added: {x}"));
        changeList.AddRange(EquipmentRemovedItems.Select(x => $"Equipment Removed: {x}"));
        changeList.AddRange(EquipmentWeightChanges.Select(x => $"Equipment Weight Changed: {x.Key}"));

        changeList.AddRange(AmmoAddedItems.Select(x => $"Ammo Added: {x}"));
        changeList.AddRange(AmmoRemovedItems.Select(x => $"Ammo Removed: {x}"));
        changeList.AddRange(AmmoWeightChanges.Select(x => $"Ammo Weight Changed: {x.Key}"));

        changeList.AddRange(ChancesWeightChanges.Select(x => $"Chance Weight Changed: {x.Key}"));

        changeList.AddRange(GenerationWeightChanges.Select(x => $"Generation Weight Changed: {x.Key}"));
        changeList.AddRange(GenerationWhitelistWeightChanges.Select(x => $"Generation Whitelist Weight Changed: {x.Key}"));
        changeList.AddRange(GenerationWhitelistAddedItems.Select(x => $"Generation Whitelist Added: {x}"));
        changeList.AddRange(GenerationWhitelistRemovedItems.Select(x => $"Generation Whitelist Removed: {x}"));

        changeList.AddRange(AppearanceAddedItems.Select(x => $"Appearance Added: {x}"));
        changeList.AddRange(AppearanceRemovedItems.Select(x => $"Appearance Removed: {x}"));
        changeList.AddRange(AppearanceWeightChanges.Select(x => $"Appearance Weight Changed: {x.Key}"));

        if (pendingChanges.Contains("_presetName"))
        {
            changeList.Add($"Preset Name Changed: {ModConfig.Config.PresetName}");
        }
        if (pendingChanges.Contains("_presetEnable"))
        {
            changeList.Add($"Preset Enablement Changed: {ModConfig.Config.UsePreset}");
        }

        if (!changeList.Any())
            changeList.Add("No pending changes detected.");

        var parameters = new DialogParameters<RefreshWarningDialog>
        {
            { x => x.ChangeList, changeList },
            { x => x.ButtonText, "Save Changes" },
            { x => x.Color, Color.Primary }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, BackgroundClass = "custom-blur-background" };
        var dialog = await DialogService.ShowAsync<RefreshWarningDialog>("Navigation Blocked: Unsaved Changes", parameters, options);
        var result = await dialog.Result;

        if (result is not null && !result.Canceled)
        {
            await SaveData();
        }
    }

    
    public async ValueTask DisposeAsync()
    {
        _locationChangingRegistration?.Dispose();
    }

    MudTheme APBSThemeAdjustments = new MudTheme()
    {
        PaletteDark = new PaletteDark()
        {
                Background = "#27272F",
                Info = "#776BE7",
                Warning = "#8AABA1",
                Error = "#FF4081"
        },
        
    };

    public MainLayout()
    {
        _app = this;
    }

    public static void EnableUnsavedChangesButton()
    {
        _unsavedChanges = true;
        _app?.StateHasChanged();
    }

    public static void TriggerUIRefresh()
    {
        _app?.StateHasChanged();
    }

    void DrawerToggle()
    {
        _drawerOpen = !_drawerOpen;
    }
    private async Task SaveData()
    {
        try
        {
            _isSaving = true;
            StateHasChanged();

            var updatePresetOnDisk = HasPendingPresetNameOrFolderChange();

            if (HasPendingPresetChanges())
            {
                updatePresetOnDisk = true;
                ApplyPresetChanges();
            }
            var result = await ModConfig.SaveConfig(updatePresetOnDisk);

            StateHasChanged();
            switch (result)
            {
                case ConfigOperationResult.Success:
                    Snackbar.Add("Config saved successfully.", Severity.Info, config => { config.ShowCloseIcon = false; });
                    if (HasPendingPresetChanges())
                    {
                        OnPresetSaved?.Invoke();
                        OnPresetChanged?.Invoke();
                    }
                    ClearPendingChanges();
                    _unsavedChanges = false;
                    _isInRaid = false;
                    break;
                case ConfigOperationResult.InRaid:
                    Snackbar.Add("Someone is in raid. No changes made.", Severity.Error, config => { config.ShowCloseIcon = false; });
                    _isInRaid = true;
                    break;
                case ConfigOperationResult.ActiveProcess:
                    Snackbar.Add("Another process is already running.", Severity.Warning, config => { config.ShowCloseIcon = false; });
                    break;
                case ConfigOperationResult.Failure:
                default:
                    Snackbar.Add("Config failed to save.", Severity.Error, config => { config.ShowCloseIcon = false; });
                    break;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Unexpected error: {ex.Message}", Severity.Error, config => { config.ShowCloseIcon = false; });
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }
    
    private async Task RefreshData()
    {
        if (_unsavedChanges || pendingChanges.Count > 0)
        {
            var changeCount = pendingChanges.Count switch
            {
                > 1 => $"{pendingChanges.Count} unsaved changes",
                1 => "1 unsaved change",
                _ => "unsaved changes"
            };

            var parameters = new DialogParameters<RefreshWarningDialog>
            {
                { x => x.ChangeList, pendingChanges },
                { x => x.ButtonText, "Reload Anyway" },
                { x => x.Color, Color.Secondary }
            };

            var options = new DialogOptions { MaxWidth = MaxWidth.Medium, BackgroundClass = "custom-blur-background" };

            var dialog = await DialogService.ShowAsync<RefreshWarningDialog>($"You have {changeCount}.", parameters, options);
            var result = await dialog.Result;

            if (result is not null && !result.Canceled)
                await DiscardChangesAndReload();

            return;
        }

        try
        {
            _isReloading = true;
            StateHasChanged();

            var result = await ModConfig.ReloadConfig();
            StateHasChanged();

            switch (result)
            {
                case ConfigOperationResult.Success:
                    Snackbar.Add("Config reloaded successfully.", Severity.Info, cfg => cfg.ShowCloseIcon = false);
                    _isInRaid = false;
                    _unsavedChanges = false;
                    ClearPendingChanges();
                    break;
                case ConfigOperationResult.InRaid:
                    Snackbar.Add("Someone is in raid. No changes made.", Severity.Error, cfg => cfg.ShowCloseIcon = false);
                    _isInRaid = true;
                    break;
                case ConfigOperationResult.ActiveProcess:
                    Snackbar.Add("Another process is already running.", Severity.Warning, cfg => cfg.ShowCloseIcon = false);
                    break;
                case ConfigOperationResult.Failure:
                default:
                    Snackbar.Add("Config failed to reload.", Severity.Error, cfg => cfg.ShowCloseIcon = false);
                    break;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Unexpected error: {ex.Message}", Severity.Error, cfg => cfg.ShowCloseIcon = false);
        }
        finally
        {
            _isReloading = false;
            StateHasChanged();
        }
    }

    private async Task ShowPendingChanges()
    {
        var changeCount = pendingChanges.Count switch
        {
            > 1 => $"{pendingChanges.Count} changes",
            1 => "1 change",
            _ => "changes"
        };
        var parameters = new DialogParameters<RefreshWarningDialog>
            {
                { x => x.ChangeList, pendingChanges },
                { x => x.ButtonText, "OK" },
                { x => x.showCancel, false },
                { x => x.Color, Color.Default }
            };

        var options = new DialogOptions() { MaxWidth = MaxWidth.Medium, BackgroundClass = "custom-blur-background" };

        await DialogService.ShowAsync<RefreshWarningDialog>($"You have {changeCount}.", parameters, options);
    }

    private async Task DiscardChangesAndReload()
    {
        var changeCount = pendingChanges.Count switch
        {
            > 1 => $"{pendingChanges.Count} changes",
            1 => "1 change",
            _ => "changes"
        };

        try
        {
            _isReloading = true;
            StateHasChanged();

            var result = await ModConfig.ReloadConfig();

            switch (result)
            {
                case ConfigOperationResult.Success:
                    _isInRaid = false;
                    Snackbar.Add($"{changeCount} discarded and config reloaded.", Severity.Warning, cfg => cfg.ShowCloseIcon = false);
                    ClearPendingChanges();
                    _unsavedChanges = false;
                    break;

                case ConfigOperationResult.InRaid:
                    Snackbar.Add("Someone is in raid. No changes made.", Severity.Error, cfg => cfg.ShowCloseIcon = false);
                    _isInRaid = true;
                    break;

                case ConfigOperationResult.ActiveProcess:
                    Snackbar.Add("Another process is already running.", Severity.Warning, cfg => cfg.ShowCloseIcon = false);
                    break;

                case ConfigOperationResult.Failure:
                default:
                    Snackbar.Add("Config failed to reload.", Severity.Error, cfg => cfg.ShowCloseIcon = false);
                    break;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Unexpected error: {ex.Message}", Severity.Error, cfg => cfg.ShowCloseIcon = false);
        }
        finally
        {
            _isReloading = false;
            StateHasChanged();
        }
    }

    private void RefreshPage()
    {
        _isInRaid = RaidInformation.IsInRaid;
        StateHasChanged();
    }
    
    private void ApplyPresetChanges()
    {
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[1].EquipmentData, "1");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[2].EquipmentData, "2");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[3].EquipmentData, "3");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[4].EquipmentData, "4");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[5].EquipmentData, "5");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[6].EquipmentData, "6");
        ApplyEquipmentChangesToTier(Dataloader.AllTierDataClean.Tiers[7].EquipmentData, "7");
        
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[1].AmmoData, "1");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[2].AmmoData, "2");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[3].AmmoData, "3");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[4].AmmoData, "4");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[5].AmmoData, "5");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[6].AmmoData, "6");
        ApplyAmmoChangesToTier(Dataloader.AllTierDataClean.Tiers[7].AmmoData, "7");
        
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[1].ChancesData, "1");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[2].ChancesData, "2");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[3].ChancesData, "3");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[4].ChancesData, "4");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[5].ChancesData, "5");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[6].ChancesData, "6");
        ApplyChancesChangesToTier(Dataloader.AllTierDataClean.Tiers[7].ChancesData, "7");

        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[1].AppearanceData, "1");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[2].AppearanceData, "2");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[3].AppearanceData, "3");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[4].AppearanceData, "4");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[5].AppearanceData, "5");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[6].AppearanceData, "6");
        ApplyAppearanceChangesToTier(Dataloader.AllTierDataClean.Tiers[7].AppearanceData, "7");
    }
    
    private static readonly Dictionary<string, ApbsEquipmentSlots> _stringToSlot = new()
    {
        { "Headwear", ApbsEquipmentSlots.Headwear },
        { "Earpiece", ApbsEquipmentSlots.Earpiece },
        { "FaceCover", ApbsEquipmentSlots.FaceCover },
        { "ArmorVest", ApbsEquipmentSlots.ArmorVest },
        { "Eyewear", ApbsEquipmentSlots.Eyewear },
        { "ArmBand", ApbsEquipmentSlots.ArmBand },
        { "TacticalVest", ApbsEquipmentSlots.TacticalVest },
        { "Pockets", ApbsEquipmentSlots.Pockets },
        { "Backpack", ApbsEquipmentSlots.Backpack },
        { "SecuredContainer", ApbsEquipmentSlots.SecuredContainer },
        { "FirstPrimaryWeapon_LongRange", ApbsEquipmentSlots.FirstPrimaryWeapon_LongRange },
        { "FirstPrimaryWeapon_ShortRange", ApbsEquipmentSlots.FirstPrimaryWeapon_ShortRange },
        { "SecondPrimaryWeapon_LongRange", ApbsEquipmentSlots.SecondPrimaryWeapon_LongRange },
        { "SecondPrimaryWeapon_ShortRange", ApbsEquipmentSlots.SecondPrimaryWeapon_ShortRange },
        { "Holster", ApbsEquipmentSlots.Holster },
        { "Scabbard", ApbsEquipmentSlots.Scabbard },
        { "ArmouredRig", ApbsEquipmentSlots.ArmouredRig }
    };

    
    private void ApplyEquipmentChangesToTier(EquipmentTierData tier, string tierIndex)
    {
        foreach (var prop in typeof(EquipmentTierData).GetProperties())
        {
            var botName = prop.Name;
            var botData = (ApbsEquipmentBot)prop.GetValue(tier)!;

            void ApplyToEquipment(string key, Action<Dictionary<MongoId, double>, MongoId> action)
            {
                var parts = key.Split('_');
                if (parts.Length < 4) return;

                var keyTier = parts[0];
                var keyBot = parts[1];
                var idStr = parts[^1];
                var categoryStr = string.Join("_", parts[2..^1]);

                if (!keyTier.Equals($"Tier{tierIndex}", StringComparison.OrdinalIgnoreCase))
                    return;

                if (!keyBot.Equals(botName, StringComparison.OrdinalIgnoreCase))
                    return;

                if (!_stringToSlot.TryGetValue(categoryStr, out var slot))
                    return;

                var equipmentDict = botData.Equipment;
                if (!equipmentDict.TryGetValue(slot, out var items))
                {
                    items = new Dictionary<MongoId, double>();
                    equipmentDict[slot] = items;
                }

                var id = new MongoId(idStr);
                action(items, id);
            }

            foreach (var key in EquipmentRemovedItems)
                ApplyToEquipment(key, (items, id) => items.Remove(id));

            foreach (var key in EquipmentAddedItems)
            {
                var weightKey = key + "_weight";
                ApplyToEquipment(key, (items, id) =>
                {
                    if (EquipmentWeightChanges.TryGetValue(weightKey, out var weight))
                    {
                        items[id] = weight;
                        EquipmentWeightChanges.Remove(weightKey);
                    }
                    else
                    {
                        items[id] = 1;
                    }
                });
            }

            foreach (var kvp in EquipmentWeightChanges.ToList())
            {
                if (!kvp.Key.EndsWith("_weight")) continue;
                var baseKey = kvp.Key.Substring(0, kvp.Key.Length - "_weight".Length);
                ApplyToEquipment(baseKey, (items, id) => items[id] = kvp.Value);
            }
        }
    }

    private void ApplyAmmoChangesToTier(AmmoTierData tier, string tierIndex)
    {
        foreach (var prop in typeof(AmmoTierData).GetProperties())
        {
            var botName = prop.Name;
            var botData = (Dictionary<string, Dictionary<MongoId, double>>)prop.GetValue(tier)!;

            void ApplyToAmmo(string key, Action<Dictionary<MongoId, double>, MongoId> action)
            {
                var parts = key.Split('_');
                if (parts.Length < 4) return;

                var keyTier = parts[0];
                var keyBot = parts[1];
                var idStr = parts[^1];
                var category = string.Join("_", parts[2..^1]);

                if (!keyTier.Equals($"Tier{tierIndex}", StringComparison.OrdinalIgnoreCase))
                    return;

                if (!keyBot.Equals(botName, StringComparison.OrdinalIgnoreCase))
                    return;

                if (!botData.TryGetValue(category, out var items))
                {
                    items = new Dictionary<MongoId, double>();
                    botData[category] = items;
                }

                var mongoId = new MongoId(idStr);
                action(items, mongoId);
            }

            foreach (var key in AmmoRemovedItems)
                ApplyToAmmo(key, (items, id) => items.Remove(id));

            foreach (var key in AmmoAddedItems)
            {
                var weightKey = key + "_weight";
                ApplyToAmmo(key, (items, id) =>
                {
                    if (AmmoWeightChanges.TryGetValue(weightKey, out var weight))
                    {
                        items[id] = weight;
                        AmmoWeightChanges.Remove(weightKey);
                    }
                    else
                    {
                        items[id] = 1;
                    }
                });
            }
            
            foreach (var kvp in AmmoWeightChanges.ToList())
            {
                if (!kvp.Key.EndsWith("_weight")) continue;
                var baseKey = kvp.Key.Substring(0, kvp.Key.Length - "_weight".Length);
                ApplyToAmmo(baseKey, (items, id) => items[id] = kvp.Value);
            }
        }
    }

    private static void ApplyChancesChangesToTier(ChancesTierData tierData, string tier)
    {
        foreach (var botProp in typeof(ChancesTierData).GetProperties())
        {
            var botType = botProp.Name;
            var botData = botProp.GetValue(tierData) as BotChancesData;
            if (botData?.Chances == null) continue;

            var chances = botData.Chances;

            void ApplyWeightChanges(IDictionary dict, string dictName, IEnumerable<KeyValuePair<string, double>> changes, string suffix = "")
            {
                foreach (var kvp in changes)
                {
                    var key = kvp.Key;
                    if (!string.IsNullOrEmpty(suffix) && key.EndsWith(suffix))
                        key = key.Substring(0, key.Length - suffix.Length);

                    var parts = key.Split('_', 4);
                    if (parts.Length != 4) continue;
                    if (parts[0] != $"Tier{tier}" || parts[1] != botType) continue;

                    var category = parts[2];
                    var id = parts[3];

                    if (!string.Equals(dictName, category, StringComparison.OrdinalIgnoreCase))
                        continue;

                    // eesh, I knew this would come back to bite me
                    if (dict is Dictionary<MongoId, double>)
                    {
                        var mongoId = new MongoId(id);
                        dict[mongoId] = kvp.Value;
                    }
                    else
                    {
                        dict[id] = kvp.Value;
                    }
                }
            }

            foreach (var dictProp in typeof(ApbsChances).GetProperties().Where(p => !p.Name.Equals("Generation", StringComparison.OrdinalIgnoreCase)))
            {
                var dict = dictProp.GetValue(chances) as IDictionary;
                if (dict == null) continue;

                ApplyWeightChanges(dict, dictProp.Name, ChancesWeightChanges, "_chancesWeight");
            }

            var genItems = chances.Generation?.Items;
            if (genItems == null) continue;

            foreach (var genProp in typeof(ApbsGenerationWeightingItems).GetProperties())
            {
                var genData = genProp.GetValue(genItems) as ApbsGenerationData;
                if (genData == null) continue;

                var genCategory = genProp.Name;

                foreach (var key in GenerationWhitelistAddedItems.Concat(GenerationWhitelistRemovedItems))
                {
                    var parts = key.Split('_', 4);
                    if (parts.Length != 4 || parts[0] != $"Tier{tier}" || parts[1] != botType || parts[2] != genCategory)
                        continue;

                    var id = parts[3];
                    var mongoId = new MongoId(id);

                    if (GenerationWhitelistAddedItems.Contains(key))
                    {
                        if (GenerationWhitelistWeightChanges.TryGetValue(key + "_generationWeight", out var weight))
                        {
                            genData.Whitelist[mongoId] = weight;
                            GenerationWhitelistWeightChanges.Remove(key + "_generationWeight");
                        }
                        else
                        {
                            genData.Whitelist[mongoId] = 1;
                        }
                    }
                    else if (GenerationWhitelistRemovedItems.Contains(key))
                    {
                        genData.Whitelist.Remove(mongoId);
                    }
                }

                ApplyWeightChanges(genData.Whitelist, genCategory, GenerationWhitelistWeightChanges, "_generationWeight");

                for (var slotIndex = 0; slotIndex < 8; slotIndex++)
                {
                    var slotKey = $"Tier{tier}_{botType}_{genCategory}_{slotIndex}";
                    var value = GenerationWeightChanges.TryGetValue(slotKey, out var changedValue)
                        ? changedValue
                        : genData.Weights.TryGetValue(slotIndex, out var existingValue)
                            ? existingValue
                            : 0;

                    genData.Weights[slotIndex] = value;
                }
            }
        }
    }
    
   private void ApplyAppearanceChangesToTier(AppearanceTierData tierData, string tierIndex)
    {
        void ApplyToAppearance(string key, Action<Dictionary<MongoId, double>, MongoId> action)
        {
            var parts = key.Split('_');
            if (parts.Length < 4) return;

            var keyTier = parts[0];
            var botType = parts[1];
            var category = parts[2];
            var idStr = parts[3];

            if (!keyTier.Equals($"Tier{tierIndex}", StringComparison.OrdinalIgnoreCase))
                return;

            if (category.Equals("voice", StringComparison.OrdinalIgnoreCase))
                return;

            var mongoId = new MongoId(idStr);

            Dictionary<MongoId, double>? dict = null;

            Dictionary<string, Appearance>? GetBotAppearances() => botType switch
            {
                "PmcUsec" => tierData.PmcUsec,
                "PmcBear" => tierData.PmcBear,
                _ => null
            };

            if (botType.Contains("-"))
            {
                var seasonParts = botType.Split('-', 2);
                var seasonName = seasonParts[0];
                var seasonBot = seasonParts[1];

                SeasonAppearance? season = seasonName.ToLower() switch
                {
                    "springearly" => tierData.SpringEarly,
                    "spring" => tierData.Spring,
                    "summer" => tierData.Summer,
                    "autumn" => tierData.Autumn,
                    "winter" => tierData.Winter,
                    _ => null
                };
                if (season == null) return;

                Dictionary<string, Appearance>? botAppearances = seasonBot switch
                {
                    "PmcUsec" => season.PmcUsec,
                    "PmcBear" => season.PmcBear,
                    _ => null
                };
                if (botAppearances == null) return;

                if (botAppearances.Values.FirstOrDefault() is not Appearance app) return;

                dict = category.ToLower() switch
                {
                    "body" => app.Body,
                    "feet" => app.Feet,
                    "hands" => app.Hands,
                    "head" => app.Head,
                    _ => null
                };
            }
            else
            {
                var botAppearances = GetBotAppearances();
                if (botAppearances == null) return;

                if (botAppearances.Values.FirstOrDefault() is not Appearance app) return;

                dict = category.ToLower() switch
                {
                    "body" => app.Body,
                    "feet" => app.Feet,
                    "hands" => app.Hands,
                    "head" => app.Head,
                    _ => null
                };
            }

            if (dict != null)
                action(dict, mongoId);
        }

        foreach (var key in AppearanceRemovedItems)
            ApplyToAppearance(key, (dict, id) => dict.Remove(id));

        foreach (var key in AppearanceAddedItems)
            ApplyToAppearance(key, (dict, id) =>
            {
                var weight = AppearanceWeightChanges.TryGetValue(key + "_weight", out var w) ? w : 1;
                dict[id] = weight;
                AppearanceWeightChanges.Remove(key + "_weight");
            });

        foreach (var kvp in AppearanceWeightChanges)
        {
            if (!kvp.Key.EndsWith("_weight")) continue;
            var baseKey = kvp.Key.Substring(0, kvp.Key.Length - "_weight".Length);

            ApplyToAppearance(baseKey, (dict, id) =>
            {
                if (dict.ContainsKey(id))
                    dict[id] = kvp.Value;
            });
        }
    }
}